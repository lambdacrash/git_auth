/* 
 **  mod_git_auth.c -- Apache sample git_auth module
 **  [Autogenerated via ``apxs -n git_auth -g'']
 ** 
 **  Author: lambdacrash@gmail.com
 **  Date: 04/17/2013
 **  Licence GPL2
 */ 

#include "httpd.h"
#include "http_log.h"
#include "http_config.h"
#include "http_request.h"
#include "http_protocol.h"
#include "ap_config.h"

#include "apr_pools.h"
#include "apr_hash.h"
#include "apr_optional.h"

#include "mod_auth.h"

#define GIT_AUTH_PROVIDER_NAME "git_auth"
#define GIT_AUTH_PROVIDER_VERSION "0"

typedef authn_status git_auth_status;

typedef struct {
    /* Given a username and password, expected to return AUTH_GRANTED
     * if we can validate this user/password combination.
     */
    git_auth_status (*check_password)(request_rec *r, const char *user,
            const char *password);

    /* Given a user and realm, expected to return AUTH_USER_FOUND if we
     * can find a md5 hash of 'user:realm:password'
     */
    git_auth_status (*get_realm_hash)(request_rec *r, const char *user,
            const char *realm, char **rethash);
} git_auth_provider;

typedef struct {
    char *pwfile;
} authn_file_config_rec;

static void *create_authn_file_dir_config(apr_pool_t *p, char *d)
{
    authn_file_config_rec *conf = apr_palloc(p, sizeof(*conf));
    conf->pwfile = NULL;
    return conf;
}

static const char *set_authn_file_slot(cmd_parms *cmd, void *offset, const char *f, const char *t)
{
    if (t && strcmp(t, "standard")) {
        return apr_pstrcat(cmd->pool, "Invalid auth file type: ", t, NULL);
    }

    return ap_set_file_slot(cmd, offset, f);
}


static const command_rec authn_file_cmds[] =
{
    AP_INIT_TAKE12("AuthUserFile", set_authn_file_slot,
            (void *)APR_OFFSETOF(authn_file_config_rec, pwfile),
            OR_AUTHCFG, "text file containing user IDs and passwords"),
    {NULL}
};

module AP_MODULE_DECLARE_DATA authn_file_module;

static git_auth_status check_password(request_rec *r, const char *user, const char *password)
{
    authn_file_config_rec *conf = ap_get_module_config(r->per_dir_config, &authn_file_module);
    ap_configfile_t *f;
    char l[MAX_STRING_LEN];
    apr_status_t status;
    char *file_password = NULL;

    if (!conf->pwfile) 
    {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "AuthUserFile not specified in the configuration");
        return AUTH_GENERAL_ERROR;
    }

    status = ap_pcfg_openfile(&f, r->pool, conf->pwfile);

    if (status != APR_SUCCESS) 
    {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, "Could not open password file: %s", conf->pwfile);
        return AUTH_GENERAL_ERROR;
    }

    //ap_log_rerror(APLOG_MARK, APLOG_WARNING, status, r,
    //        "URI: %s PathInfo: %s Args: %s Host: %s Method: %s CFilename: %s Filename: %s", 
    //        r->uri, r->path_info, r->args, r->hostname, r->method, r->canonical_filename, r->filename);
    // see http://ci.apache.org/projects/httpd/trunk/doxygen/structrequest__rec.html

    int inUri = 0;
    int inArgs = 0;
    char* username=NULL;
    char* repository=NULL;
    while (!(ap_cfg_getline(l, MAX_STRING_LEN, f))) 
    {
        const char *rpw, *w;
        /* Skip # or blank lines. */
        if ((l[0] == '#') || (!l[0])) 
        {
            continue;
        }
        rpw = l;
        w = ap_getword(r->pool, &rpw, ':');
        if (!strcmp(user, w)) 
        {
            file_password = ap_getword(r->pool, &rpw, ':');
        }
        else if (!strcmp("git", w)) 
        {
            repository = ap_getword(r->pool, &rpw, ':');
            inArgs = (r->args != NULL && strstr(r->args, repository));
            inUri = (r->parsed_uri.path != NULL && strstr(r->parsed_uri.path, repository));
            ap_log_rerror(APLOG_MARK, APLOG_WARNING, status, r, "repository=%s in args=%d in uri=%d", repository, inArgs, inUri);
        }
        else if ( (inArgs || inUri) && !strcmp("user", w)) 
        {
            username = ap_getword(r->pool, &rpw, ':');
            if(!strcmp(user, username) && apr_password_validate(password, file_password) == APR_SUCCESS)
            {
                ap_log_rerror(APLOG_MARK, APLOG_WARNING, status, r, "Success: user=%s repo=%s", username, repository);
                ap_cfg_closefile(f);
                return AUTH_GRANTED;
            }
        }
    }

    ap_cfg_closefile(f);
    return AUTH_DENIED;
}

static git_auth_status get_realm_hash(request_rec *r, const char *user,
        const char *realm, char **rethash)
{
    // TODO
    return AUTH_DENIED;
}


static const git_auth_provider git_auth_file_provider =
{
    &check_password,
    &get_realm_hash,
};

static void git_auth_register_hooks(apr_pool_t *p)
{
    ap_register_provider(p, 
            AUTHN_PROVIDER_GROUP, 
            GIT_AUTH_PROVIDER_NAME,
            GIT_AUTH_PROVIDER_VERSION,
            &git_auth_file_provider, 
            1 /*AP_AUTH_INTERNAL_PER_CONF*/);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA git_auth_module = {
    STANDARD20_MODULE_STUFF,
    NULL,                              /* initializer */
    NULL,                              /* dir config creator */
    NULL,                              /* dir config merger */
    NULL,                              /* server config merger */
    NULL,                              /* command table */
    git_auth_register_hooks
};
